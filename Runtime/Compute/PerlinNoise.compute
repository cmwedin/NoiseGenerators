// Each #kernel tells which function to compile; you can have many kernels
#include "/Includes/PRNG.compute"
#define UINTMAXVALUE 4294967295.0 
#define TAU 6.283185307179586

#pragma kernel CSMain
#pragma kernel GenerateLattice

float2 RotateVec2(float2 vec, float radians) {
    return float2 (vec.x*cos(radians)-vec.y*sin(radians),vec.x*sin(radians)+vec.y*cos(radians));
}

RWTexture2D<float4> _NoiseTexture;
RWTexture2D<float4> _LatticeTexture; //? Stores the values of the random lattice
RWTexture2D<float2> gradientTexture[4];
RWTexture2DArray<float2> gradientTextures;
uint _Seed; //? the value used to generate the random hash
uint _TexWidth; //? the width of the generated texture in pixels
uint _TexHeight; //? the height of the generated texture in pixels
uint _LatticeSize; //? the seperation of the lattice used to generate the noise in pixels
uint _LatticeTexWidth; //? Total width of the lattice texture
uint _LatticeTexHeight; //? Total height of the lattice texture

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if(id.x < 0 || id.x >= _TexWidth || id.y < 0 || id.y >= _TexHeight) {return;}
    
    //? Figure out where we are in the lattice
    float2 globalLatticePos = id.xy / float(_LatticeSize);
    float2 localLatticePos = frac(globalLatticePos);
    // int2 latticeIndex = floor(globalLatticePos);
    int2 latticeIndex = globalLatticePos - localLatticePos;
    float2 smoothedLocalLatticePos = localLatticePos * localLatticePos * (3.0 - 2.0 * localLatticePos); //?alternate cubic pos for smoother transitions
    
    //? Using the RGBA values of the surrounding pixels in the lattice texture rotate a unit vector by 4 different random radians
    //? Potential target for optimization as redunat work will be preformed for each pixel in the lattice cell
    //? But these calculations should be fast enough for this not to be needed
    float2 baseVec = float2(1,0); 
    float2 randomBL[4] = {
        RotateVec2(baseVec,_LatticeTexture[latticeIndex.xy].x*TAU),
        RotateVec2(baseVec,_LatticeTexture[latticeIndex.xy].y*TAU), 
        RotateVec2(baseVec,_LatticeTexture[latticeIndex.xy].z*TAU), 
        RotateVec2(baseVec,_LatticeTexture[latticeIndex.xy].w*TAU)
    }; 
    float2 randomTL[4] = {
        RotateVec2(baseVec,_LatticeTexture[int2(latticeIndex.x,latticeIndex.y+1)].x*TAU),
        RotateVec2(baseVec,_LatticeTexture[int2(latticeIndex.x,latticeIndex.y+1)].y*TAU), 
        RotateVec2(baseVec,_LatticeTexture[int2(latticeIndex.x,latticeIndex.y+1)].z*TAU), 
        RotateVec2(baseVec,_LatticeTexture[int2(latticeIndex.x,latticeIndex.y+1)].w*TAU)
    };
    float2 randomTR[4] = {
        RotateVec2(baseVec,_LatticeTexture[int2(latticeIndex.x+1,latticeIndex.y+1)].x*TAU),
        RotateVec2(baseVec,_LatticeTexture[int2(latticeIndex.x+1,latticeIndex.y+1)].y*TAU), 
        RotateVec2(baseVec,_LatticeTexture[int2(latticeIndex.x+1,latticeIndex.y+1)].z*TAU), 
        RotateVec2(baseVec,_LatticeTexture[int2(latticeIndex.x+1,latticeIndex.y+1)].w*TAU)
    }; 
    float2 randomBR[4] = {
        RotateVec2(baseVec,_LatticeTexture[int2(latticeIndex.x+1,latticeIndex.y)].x*TAU),
        RotateVec2(baseVec,_LatticeTexture[int2(latticeIndex.x+1,latticeIndex.y)].y*TAU), 
        RotateVec2(baseVec,_LatticeTexture[int2(latticeIndex.x+1,latticeIndex.y)].z*TAU), 
        RotateVec2(baseVec,_LatticeTexture[int2(latticeIndex.x+1,latticeIndex.y)].w*TAU)
    };

    float4 colA = float4 (
        dot(randomBL[0],localLatticePos),
        dot(randomBL[1],localLatticePos),
        dot(randomBL[2],localLatticePos),
        dot(randomBL[3],localLatticePos)
    );
    float4 colB = float4 (
        dot(randomTL[0],localLatticePos - float2(0,1)),
        dot(randomTL[1],localLatticePos - float2(0,1)),
        dot(randomTL[2],localLatticePos - float2(0,1)),
        dot(randomTL[3],localLatticePos - float2(0,1))
    );
    float4 colC = float4 (
        dot(randomTR[0],localLatticePos - float2(1,1)),
        dot(randomTR[1],localLatticePos - float2(1,1)),
        dot(randomTR[2],localLatticePos - float2(1,1)),
        dot(randomTR[3],localLatticePos - float2(1,1))
    );
    float4 colD = float4 (
        dot(randomBR[0],localLatticePos - float2(1,0)),
        dot(randomBR[1],localLatticePos - float2(1,0)),
        dot(randomBR[2],localLatticePos - float2(1,0)),
        dot(randomBR[3],localLatticePos - float2(1,0))
    );

    // float4 colA = float4 (
    //     dot(gradientTextures[int3(latticeIndex.xy,0)],localLatticePos),
    //     dot(gradientTextures[int3(latticeIndex.xy,1)],localLatticePos),
    //     dot(gradientTextures[int3(latticeIndex.xy,2)],localLatticePos),
    //     dot(gradientTextures[int3(latticeIndex.xy,3)],localLatticePos)
    // );
    // float4 colB = float4 (
    //     dot(gradientTextures[int3(latticeIndex.x,latticeIndex.y+1,0)],localLatticePos - float2(0,1)),
    //     dot(gradientTextures[int3(latticeIndex.x,latticeIndex.y+1,1)],localLatticePos - float2(0,1)),
    //     dot(gradientTextures[int3(latticeIndex.x,latticeIndex.y+1,2)],localLatticePos - float2(0,1)),
    //     dot(gradientTextures[int3(latticeIndex.x,latticeIndex.y+1,3)],localLatticePos - float2(0,1))
    // );
    // float4 colC = float4 (
    //     dot(gradientTextures[int3(latticeIndex.x+1,latticeIndex.y+1,0)],localLatticePos - float2(1,1)),
    //     dot(gradientTextures[int3(latticeIndex.x+1,latticeIndex.y+1,1)],localLatticePos - float2(1,1)),
    //     dot(gradientTextures[int3(latticeIndex.x+1,latticeIndex.y+1,2)],localLatticePos - float2(1,1)),
    //     dot(gradientTextures[int3(latticeIndex.x+1,latticeIndex.y+1,3)],localLatticePos - float2(1,1))
    // );
    // float4 colD = float4 (
    //     dot(gradientTextures[int3(latticeIndex.x+1,latticeIndex.y,0)],localLatticePos - float2(1,0)),
    //     dot(gradientTextures[int3(latticeIndex.x+1,latticeIndex.y,1)],localLatticePos - float2(1,0)),
    //     dot(gradientTextures[int3(latticeIndex.x+1,latticeIndex.y,2)],localLatticePos - float2(1,0)),
    //     dot(gradientTextures[int3(latticeIndex.x+1,latticeIndex.y,3)],localLatticePos - float2(1,0))
    // );

    //? Smoothed local position
    float4 colAD = lerp(colA,colD,smoothedLocalLatticePos.x);
    float4 colBC = lerp(colB,colC,smoothedLocalLatticePos.x);
    float4 fragCol = lerp(colAD,colBC,smoothedLocalLatticePos.y);

    // //? Linear local position
    // float4 colAD = lerp(colA,colD,localLatticePos.x);
    // float4 colBC = lerp(colB,colC,localLatticePos.x);
    // float4 fragCol = lerp(colAD,colBC,localLatticePos.y);

    fragCol = sqrt(2)/2*fragCol + .5; //? manipulation to get color components into [0,1] range
    _NoiseTexture[id.xy] = fragCol;
    // _NoiseTexture[id.xy] = fragCol - saturate(fragCol); //? test to verify colors components are <=1
    // _NoiseTexture[id.xy] = saturate(fragCol) - fragCol; //? test to verify colors components are >=0

    // _NoiseTexture[id.xy] = float4(gradientTextures[int3(latticeIndex.xy,3)],0,1);
    // _NoiseTexture[id.xy] = .5*colA + .5;
}

[numthreads(8,8,1)]
void GenerateLattice(uint3 id : SV_DISPATCHTHREADID) {
    if(id.x < 0 || id.x >= _LatticeTexWidth || id.y < 0 || id.y >= _LatticeTexHeight) {return;}
    
    uint hash = pcg_hash(_Seed);
    uint4 hash4d = pcg4d_hash(uint4(id.x,id.y,hash,pcg_hash(hash)));
    _LatticeTexture[id.xy] = float4(hash4d) / UINTMAXVALUE;
    float2 baseVec = float2(1,0);
    // gradientTexture[0][id.xy] = RotateVec2(baseVec,_LatticeTexture[id.xy].x*TAU);
    // gradientTexture[1][id.xy] = RotateVec2(baseVec,_LatticeTexture[id.xy].y*TAU);
    // gradientTexture[2][id.xy] = RotateVec2(baseVec,_LatticeTexture[id.xy].z*TAU);
    // gradientTexture[3][id.xy] = RotateVec2(baseVec,_LatticeTexture[id.xy].w*TAU);
    gradientTextures[int3(id.xy,0)] = RotateVec2(baseVec,_LatticeTexture[id.xy].x*TAU);
    gradientTextures[int3(id.xy,1)] = RotateVec2(baseVec,_LatticeTexture[id.xy].y*TAU);
    gradientTextures[int3(id.xy,2)] = RotateVec2(baseVec,_LatticeTexture[id.xy].z*TAU);
    gradientTextures[int3(id.xy,3)] = RotateVec2(baseVec,_LatticeTexture[id.xy].w*TAU);
}

